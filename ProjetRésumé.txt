R√©sum√© du projet.

La structure du projet est celle ci

Dossier du projet contenant:
config.py
Dossier agents
Dossiers roles
Dossiers skills
Dossiers data
Dossier utils
Dossier tools
dossier environments
dossier teams
dossier memory
dossier scripts

Le fichier config.py contient le code suivant :

import ollama

class Config:
    DEBUG_MODE = True
    LLM_MODEL = "llama3"
    LLM_SETTINGS = {
        "temperature": 0.7,
        "max_tokens": 512,
        "top_p": 0.9,
        "frequency_penalty": 0,
        "presence_penalty": 0,
        "ollama_host": "http://localhost:11434",  # URL du serveur Ollama
    }

    MEMORY = {}  # Stockage centralis√© de la m√©moire partag√©e

    @staticmethod
    def query_llm(prompt):
        """Effectue une requ√™te au LLM via Ollama"""
        response = ollama.chat(model=Config.LLM_MODEL, messages=[{"role": "user", "content": prompt}])
        return response["message"]["content"]

    @staticmethod
    def update_memory(agent_name, key, value):
        """Met √† jour la m√©moire partag√©e pour un agent sp√©cifique"""
        if agent_name not in Config.MEMORY:
            Config.MEMORY[agent_name] = {}
        Config.MEMORY[agent_name][key] = value

    @staticmethod
    def retrieve_memory(agent_name, key):
        """R√©cup√®re un √©l√©ment de la m√©moire partag√©e"""
        return Config.MEMORY.get(agent_name, {}).get(key, None)
    DEBUG_MODE = True  # Passe √† False en production

    @staticmethod
    def debug_log(message: str):
        """Affiche les logs uniquement si DEBUG_MODE est activ√©."""
        if Config.DEBUG_MODE:
            print(message)
            
            
            
Le dossier agents contient les fichiers et leur code suivant :

Fichier base_agent.py

from skills.communication import CommunicationSkill
from skills.memory_access import MemorySkill
from skills.llm_skill import LLMSkill  # üî• Nouveau skill !
from config import Config
class BaseAgent:
    def __init__(self, name, role=None, skills=None):
        self.name = name
        self.role = role
        self.skills = {}
        

        # Ajout des skills fournis (optionnels)
        if skills:
            for skill_class in skills:
                self.add_skill(skill_class)
        def add_skill(self, skill_class):
              """Ajoute une nouvelle comp√©tence √† l‚Äôagent."""
              skill = skill_class(self)
              self.skills[skill.__class__.__name__] = skill  # Stockage standardis√©
              Config.debug_log(f"‚úÖ {self.name} a re√ßu la comp√©tence {skill.__class__.__name__}")

    def __str__(self):
        return f"Agent: {self.name}"

    def __repr__(self):
        return f"BaseAgent(name={self.name})"

    def add_skill(self, skill_class):
         """Ajoute une nouvelle comp√©tence √† l‚Äôagent."""
         skill = skill_class(self)
         self.skills[skill.name] = skill  # üî• Correction ici : on utilise skill.name !
         Config.debug_log(f"üõ†Ô∏è {self.name} apprend le skill: {skill.name}")

    def execute_skill(self, skill_name, *args, **kwargs):
          """Ex√©cute une comp√©tence de l‚Äôagent."""
          Config.debug_log(f"üîç {self.name} essaie d'ex√©cuter le skill: {skill_name}")

          if skill_name in self.skills:
                 Config.debug_log(f"‚úÖ {self.name} ex√©cute {skill_name} avec {args}, {kwargs}")
                 return self.skills[skill_name].perform(*args, **kwargs)

          Config.debug_log(f"‚ö†Ô∏è {self.name} ne poss√®de pas la comp√©tence {skill_name}! (Comp√©tences disponibles: {list(self.skills.keys())})")


    def act(self, action_name, *args, **kwargs):
        """Ex√©cute une action d√©finie par le r√¥le, sinon cherche un skill √©quivalent."""
        if self.role:
            return self.role.perform_action(action_name, *args, **kwargs)

        # Si l'action correspond √† un skill, on l'ex√©cute
        if action_name in self.skills:
            return self.skills[action_name].perform(*args, **kwargs)  # üî• Correction ici aussi !

        Config.debug_log(f"‚ö†Ô∏è {self.name} n‚Äôa pas de r√¥le d√©fini et ne peut pas effectuer {action_name}!")

Fichier Debator_agent.py

from .base_agent import BaseAgent
from skills.llm_skill import LLMSkill
from skills.debate_skill import DebateSkill
from config import Config
class DebatorAgent(BaseAgent):
    """Un agent sp√©cialis√© dans les d√©bats."""

    def __init__(self, name, role):
        super().__init__(name, role)
        self.add_skill(LLMSkill)  # ‚úÖ Passer la classe et non l'instance
        self.add_skill(DebateSkill)
        Config.debug_log(f"üìú Comp√©tences de {self.name}: {list(self.skills.keys())}")

    def debate(self, topic, opponent):
        """Engage un √©change avec un adversaire sur un sujet donn√©."""
        response = self.execute_skill("debate", topic=topic, opponent_name=opponent.name)
        return response


Le dossiers r√¥les contient les fichiers et leur code suivants :

Fichier base_role.py

from config import Config  # Pour les logs

class BaseTool:
    def __init__(self, name):
        self.name = name

    def run(self, *args, **kwargs):
        """M√©thode √† impl√©menter dans les outils sp√©cifiques"""
        Config.debug_log(f"üõ†Ô∏è [BaseTool] L'outil {self.name} a √©t√© utilis√© avec {args}, {kwargs}")
        raise NotImplementedError("La m√©thode 'run' doit √™tre impl√©ment√©e dans les sous-classes.")


Fichier scientifique.py

class Scientifique:
    name = "Scientifique"
    description = "Un expert qui d√©fend les faits scientifiques √©tablis."
    cognitive_biases = [
        "D√©pendance aux publications scientifiques",
        "Rejet des sources non v√©rifi√©es",
        "Prudence dans l'affirmation des r√©sultats"
    ]


Fichier conspirationniste.py

class Conspirationniste:
    name = "Conspirationniste"
    description = "Un sceptique qui rejette les arguments officiels et pr√©f√®re les th√©ories alternatives."
    cognitive_biases = [
        "Confirmation bias (ne croire que ce qui va dans son sens)",
        "Cherry-picking (s√©lectionner uniquement certaines preuves)",
        "Appeal to ignorance (dire qu'une absence de preuve prouve un complot)"
    ]


Le dossier skills contient les fichiers et leur code suivants :

Fichier base_skill.py

from abc import ABC, abstractmethod

class BaseSkill(ABC):
    """Classe de base pour tous les skills."""
    
    def __init__(self, agent):
        self.agent = agent  # L‚Äôagent qui poss√®de ce skill
    
    @abstractmethod
    def perform(self, *args, **kwargs):
        """M√©thode principale √† impl√©menter par chaque skill."""
        pass

Fichier debate_skill.py

from .base_skill import BaseSkill
from config import Config

class DebateSkill(BaseSkill):
    """Skill permettant de g√©n√©rer des arguments en fonction du r√¥le et du contexte."""
    name = "debate"

    def __init__(self, agent):
        super().__init__(agent)
        
    def perform(self, topic, opponent_name):
        """G√©n√®re une r√©ponse argument√©e dans un d√©bat."""
        
        prompt = f"""
Tu es {self.agent.name}, un {self.agent.role.name}.
Tu d√©bats avec {opponent_name} sur le sujet : {topic}.

R√©ponds directement √† {opponent_name} en d√©fendant ta position :
{self.agent.role.description}

üß† Ton raisonnement est influenc√© par ces biais : {', '.join(self.agent.role.cognitive_biases)}
"""
        return self.agent.execute_skill("llm", prompt)


Fichier communication.py

from skills.base_skill import BaseSkill
from config import Config

class CommunicationSkill(BaseSkill):
    """Skill permettant la communication entre agents, avec un humain ou avec le LLM."""

    def send_to_agent(self, recipient, message):
        """Envoie un message √† un autre agent."""
        if "CommunicationSkill" in recipient.skills:
            Config.debug_log(f"üì¢ {self.agent.name} dit √† {recipient.name} : {message}")
            recipient.execute_skill("CommunicationSkill", "receive_message", message)
        else:
            Config.debug_log(f"‚ö†Ô∏è {recipient.name} ne peut pas recevoir de messages (pas de CommunicationSkill)")

    def broadcast(self, agents, message):
        """Envoie un message √† plusieurs agents."""
        Config.debug_log(f"üì£ {self.agent.name} envoie √† toute l‚Äô√©quipe : {message}")
        for agent in agents:
            self.send_to_agent(agent, message)

    def talk_to_llm(self, prompt):
        """Dialogue avec le mod√®le LLM."""
        Config.debug_log(f"üó®Ô∏è {self.agent.name} parle au LLM...")
        return Config.query_llm(prompt)

    def receive_message(self, message):
        """R√©ception d'un message (placeholder, peut √™tre personnalis√© par agent)."""
        Config.debug_log(f"üì® {self.agent.name} a re√ßu : {message}")

    def perform(self, mode, *args, **kwargs):
        """Ex√©cute le bon mode de communication."""
        actions = {
            "agent": self.send_to_agent,
            "broadcast": self.broadcast,
            "llm": self.talk_to_llm,
            "receive_message": self.receive_message,
        }
        if mode in actions:
            return actions[mode](*args, **kwargs)
        else:
            Config.debug_log(f"‚ö†Ô∏è Mode de communication inconnu : {mode}")

Fichier llm_skill.py

from .base_skill import BaseSkill
from config import Config  # üî• Import direct de la config existante

class LLMSkill(BaseSkill):
    name = "llm"

    def __init__(self, agent):
        super().__init__(agent)

    def perform(self, prompt, **kwargs):
        """Envoie une requ√™te au LLM configur√© dans `Config`."""
        Config.debug_log(f"ü§ñ {self.agent.name} interroge le LLM avec : {prompt}")

        try:
            response = Config.query_llm(prompt, **kwargs)
            if not response or not isinstance(response, str):
                raise ValueError("R√©ponse LLM invalide")
            
            Config.debug_log(f"üì® R√©ponse du LLM : {response}")
            return response
        
        except Exception as e:
            Config.debug_log(f"‚ùå Erreur lors de la requ√™te LLM : {e}")
            return None  # Pour √©viter les crashs et permettre une gestion propre

Fichier memory_access.py

from config import Config
from skills.base_skill import BaseSkill

class MemorySkill(BaseSkill):
    """Permet √† l'agent d'acc√©der √† la m√©moire partag√©e."""

    def perform(self, action: str, *args, **kwargs):
        """Choisit l‚Äôaction m√©moire en fonction de la commande re√ßue."""
        actions = {
            "store": self.store_memory,
            "retrieve": self.retrieve_memory,
            "forget": self.forget_memory
        }
        if action in actions:
            return actions[action](*args, **kwargs)
        else:
            Config.debug_log(f"‚ùå Action m√©moire inconnue : {action}")

    def store_memory(self, key: str, value: str):
        """Stocke une donn√©e en m√©moire."""
        Config.update_memory(self.agent.name, key, value)
        Config.debug_log(f"üß† {self.agent.name} a m√©moris√© {key} : {value}")

    def retrieve_memory(self, key: str):
        """R√©cup√®re une donn√©e en m√©moire."""
        value = Config.retrieve_memory(self.agent.name, key)
        if value is None:
            Config.debug_log(f"‚ö†Ô∏è {self.agent.name} n'a aucune m√©moire pour {key}")
        else:
            Config.debug_log(f"üîç {self.agent.name} r√©cup√®re {key} : {value}")
        return value

    def forget_memory(self, key: str):
        """Efface une m√©moire sp√©cifique uniquement si elle existe."""
        if Config.retrieve_memory(self.agent.name, key) is not None:
            Config.update_memory(self.agent.name, key, None)
            Config.debug_log(f"üöÆ {self.agent.name} a oubli√© {key}")
        else:
            Config.debug_log(f"‚ö†Ô∏è {self.agent.name} ne pouvait pas oublier {key} (non existant)")


Le dossier tools contient le fichier et son code suivant:

Fichier base_tool.py

from config import Config  # Pour les logs

class BaseTool:
    def __init__(self, name):
        self.name = name

    def run(self, *args, **kwargs):
        """M√©thode √† impl√©menter dans les outils sp√©cifiques"""
        Config.debug_log(f"üõ†Ô∏è [BaseTool] L'outil {self.name} a √©t√© utilis√© avec {args}, {kwargs}")
        raise NotImplementedError("La m√©thode 'run' doit √™tre impl√©ment√©e dans les sous-classes.")

Le dossier environments contient les fichiers et leur code suivants :

Fichier base_env.py

from config import Config  # ‚úÖ Import de la configuration

class BaseEnvironment:
    def __init__(self, name, rules=None):
        self.name = name
        self.rules = rules if rules else {}

    def enforce_rules(self, action):
        """V√©rifie si une action respecte les r√®gles de l‚Äôenvironnement"""
        if action in self.rules:
            result = self.rules[action]()
            Config.debug_log(f"üåç R√®gle appliqu√©e sur {action} : {result}")
            return result
        
        Config.debug_log(f"‚úÖ Aucune r√®gle sp√©cifique pour {action}, action autoris√©e.")
        return True  # ‚úÖ Action autoris√©e par d√©faut

Fichier debate_env.py

from environments.base_env import BaseEnvironment
from config import Config  # Pour le logging

class DebateEnvironment:
    """G√®re l'√©change entre les agents dans un d√©bat."""

    def __init__(self, agents, rounds=3):
        self.agents = agents
        self.rounds = rounds

    def start(self, topic):
        """Lance le d√©bat sur un nombre d√©fini de rounds."""
        print(f"üéôÔ∏è D√©but du d√©bat sur : {topic}")

        for round_num in range(1, self.rounds + 1):
            print(f"\nüîÑ Round {round_num}/{self.rounds}\n")
            for i in range(0, len(self.agents), 2):  # Paires d'agents
                if i + 1 < len(self.agents):  # V√©rifie qu'on a un adversaire
                    agent1, agent2 = self.agents[i], self.agents[i + 1]
                    response1 = agent1.debate(topic, agent2)
                    response2 = agent2.debate(topic, agent1)

                    print(f"üéôÔ∏è {agent1.name}: {response1}")
                    print(f"üéôÔ∏è {agent2.name}: {response2}")


Le dossier teams contient les fichiers et leurs codes suivant :

Fichier base_team.py

from config import Config  # ‚úÖ Import de la configuration
from agents.base_agent import BaseAgent  # ‚úÖ Import de la classe Agent si n√©cessaire
from environments.base_env import BaseEnvironment  # ‚úÖ Import de l'environnement si n√©cessaire

class BaseTeam:
    def __init__(self, name, agents=None, environment=None):
        self.name = name
        self.agents = set(agents) if agents else set()
        self.environment = environment

    def add_agent(self, agent: BaseAgent):
        if agent in self.agents:
            Config.debug_log(f"‚ö†Ô∏è {agent.name} est d√©j√† dans l'√©quipe {self.name}.")
        else:
            self.agents.add(agent)
            Config.debug_log(f"‚úÖ {agent.name} rejoint l'√©quipe {self.name}.")

    def execute_task(self, action_name, *args, **kwargs):
        Config.debug_log(f"\nüöÄ √âquipe {self.name} ex√©cute : {action_name}")
        
        if self.environment and not self.environment.enforce_rules(action_name):
            Config.debug_log(f"‚ö†Ô∏è Action {action_name} interdite dans l'environnement {self.environment.name}!")
            return None

        responses = {}
        for agent in self.agents:
            try:
                responses[agent.name] = agent.act(action_name, *args, **kwargs)
            except Exception as e:
                Config.debug_log(f"‚ùå Erreur lors de l'ex√©cution de {action_name} par {agent.name} : {e}")
        
        return responses


Fichier debate_team.py

from teams.base_team import BaseTeam
from environments.debate_env import DebateEnvironment
from config import Config  # Pour le logging

class DebateTeam:
    def __init__(self, agents, environment, rounds=5):
        self.agents = agents
        self.environment = environment
        self.rounds = rounds  # Nombre de rounds configur√©

    def start_debate(self, topic):
        """Lance un d√©bat en plusieurs rounds."""
        argument = None  # Premier argument non d√©fini

        for round_number in range(1, self.rounds + 1):
            print(f"\nüéôÔ∏è **Round {round_number}/{self.rounds}**")

            for i in range(len(self.agents)):
                speaker = self.agents[i]
                opponent = self.agents[(i + 1) % len(self.agents)]  # Tourne entre les agents
                
                argument = speaker.execute_skill("debate", topic, opponent.name, argument)
                print(f"üó£Ô∏è {speaker.name} : {argument}")

                if argument is None:
                    print(f"‚ùå {speaker.name} n‚Äôa pas pu r√©pondre.")
                    return

Le dossier memory contient le fichier et son code suivant:

Fichier memory.py

class Memory:
    """M√©moire centrale pouvant √™tre partag√©e entre plusieurs agents."""
    
    def __init__(self):
        self.global_memory = []
    
    def store(self, info):
        """Ajoute une information √† la m√©moire globale."""
        self.global_memory.append(info)
    
    def retrieve(self, n=5):
        """R√©cup√®re les derni√®res informations m√©moris√©es."""
        return self.global_memory[-n:]
        
Les dossiers data et utils sont vides. Le dossier scripts contient un fichier test.py qui me permet de tester le projet.
Tous les dossiers continnent un __init__.py.
